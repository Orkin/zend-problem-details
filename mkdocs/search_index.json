{
    "docs": [
        {
            "location": "/",
            "text": "Problem Details for PSR-7 Applications\n\n\n\n\n\n\nThis library provides custom response types, error handling middleware, and\nexception types for \nPSR-7\n applications.\n\n\nInstallation\n\n\nThis library currently depends on an unreleased patch to willdurand/negotiation.\nYour first step is adding a repository entry to your \ncomposer.json\n for\nretrieving that patch:\n\n\n\"repositories\": [\n    {\"type\": \"vcs\", \"url\": \"https://github.com/weierophinney/negotiation.git\"}\n]\n\n\n\n\nYou will then need to provide a manual specification for the\n\nwilldurand/negotiation\n requirement within \ncomposer.json\n:\n\n\n\"require\": {\n      \"willdurand/negotiation\": \"dev-feature/plus-part-matching as 2.3.0\"\n}\n\n\n\n\nOnce you have made those changes, run the following to install this library:\n\n\n$ composer require weierophinney/problem-details\n\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build",
            "title": "Home"
        },
        {
            "location": "/#problem-details-for-psr-7-applications",
            "text": "This library provides custom response types, error handling middleware, and\nexception types for  PSR-7  applications.",
            "title": "Problem Details for PSR-7 Applications"
        },
        {
            "location": "/#installation",
            "text": "This library currently depends on an unreleased patch to willdurand/negotiation.\nYour first step is adding a repository entry to your  composer.json  for\nretrieving that patch:  \"repositories\": [\n    {\"type\": \"vcs\", \"url\": \"https://github.com/weierophinney/negotiation.git\"}\n]  You will then need to provide a manual specification for the willdurand/negotiation  requirement within  composer.json :  \"require\": {\n      \"willdurand/negotiation\": \"dev-feature/plus-part-matching as 2.3.0\"\n}  Once you have made those changes, run the following to install this library:  $ composer require weierophinney/problem-details",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build",
            "title": "Documentation"
        },
        {
            "location": "/intro/",
            "text": "Problem Details\n\n\nThis library addresses \nRFC 7807: Problem Details for HTTP APIs\n\nfor usage with \nPSR-7 HTTP Messages\n and\n\nhttp-interop/http-middleware\n.\n\n\nProblem Details for HTTP APIs\n\n\nWhen developing APIs, it is good practice to:\n\n\n\n\nUse HTTP status codes to help convey error status.\n\n\nProvide sufficient error detail to clients.\n\n\n\n\nUnfortunately, unless you are using a documented\n\nRPC\n format such as\nXML-RPC, JSON-RPC, or SOAP, \nhow\n to return error details is not dictated, and\nmany API developers end up creating their own formats. Most standardized\nRPC formats do not use the HTTP status code to convey an error, only the\npayload, and, in fact, most clients of such services will fail if a non-200\nstatus is returned.\n\n\nRFC 7807 provides a standard format for returning problem details from HTTP\nAPIs. In particular, it specifies the following:\n\n\n\n\nError responses MUST use standard HTTP status codes in the 400 or 500 range to\n  detail the general category of error.\n\n\nError responses will be of the \nContent-Type\n \napplication/problem\n,\n  appending a serialization format of either \njson\n or \nxml\n:\n  \napplication/problem+json\n, \napplication/problem+xml\n.\n\n\nError responses will have each of the following keys:\n\n\ndetail\n, a human-readable description of the specific error.\n\n\ntype\n, a unique URI for the general error type, generally pointing to\n    human-readable documentation of that given type.\n\n\ntitle\n, a short, human-readable title for the general error type; the title\n    should not change for given \ntype\ns.\n\n\nstatus\n, conveying the HTTP status code; this is so that all information\n    is in one place, but also to correct for changes in the status code due to\n    usage of proxy servers.\n\n\n\n\nOptionally, an \ninstance\n key may be present, with a unique URI for the specific\nerror; this will often point to an error log for that specific response.\n\n\nFinally, problem details are \nextensible\n. You may provide additional keys that\ngive the consumer more information about the error. As an example, in an API\nthat has rate limiting, you may want to indicate how many requests the user has\nmade, what the rate limit is, and when the limit resets:\n\n\n{\n    \"type\": \"https://example.com/problems/rate-limit-exceeded\",\n    \"title\": \"You have exceeded your API rate limit.\",\n    \"detail\": \"You have hit your rate limit of 5000 requests per hour.\",\n    \"requests_this_hour\": 5025,\n    \"rate_limit\": 5000,\n    \"rate_limit_reset\": \"2017-05-03T14:39-0500\"\n}\n\n\n\n\nCustom errors\n\n\nWhat if you have custom error types?\n\n\nRFC 7807 specifically allows you to define these with the following:\n\n\n\n\nA URI to documentation of the error \ntype\n.\n\n\nA human-readable \ntitle\n describing the error type.\n\n\nOne or more HTTP \nstatus\n codes associated with the error type.\n\n\n\n\nFor your custom errors, you use the above with a problem details response; if\nthe problem type requires additional information, you provide it within the\npayload, and document that information at the URI describing the type.\n\n\nThis approach allows usage of a single, general-purpose media type for returning\nproblem details for your HTTP API, while allowing full customization of what\ntypes of errors you report.\n\n\nProblemDetails\n\n\nThis library provides custom PSR-7 responses for JSON and XML representations of\n\napplication/problem\n. Additionally, it provides a factory that will introspect\nthe contents of a provided \nAccept\n header in order to determine which\nrepresentation to return, defaulting to the XML representation. This factory may\nthen be composed in middleware in order to create and return problem details\nresponses.\n\n\nAdditionally, the library provides middleware that acts as an error and\nexception handler and wrapping calls to a delegate, converting each into problem\ndetails responses.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#problem-details",
            "text": "This library addresses  RFC 7807: Problem Details for HTTP APIs \nfor usage with  PSR-7 HTTP Messages  and http-interop/http-middleware .",
            "title": "Problem Details"
        },
        {
            "location": "/intro/#problem-details-for-http-apis",
            "text": "When developing APIs, it is good practice to:   Use HTTP status codes to help convey error status.  Provide sufficient error detail to clients.   Unfortunately, unless you are using a documented RPC  format such as\nXML-RPC, JSON-RPC, or SOAP,  how  to return error details is not dictated, and\nmany API developers end up creating their own formats. Most standardized\nRPC formats do not use the HTTP status code to convey an error, only the\npayload, and, in fact, most clients of such services will fail if a non-200\nstatus is returned.  RFC 7807 provides a standard format for returning problem details from HTTP\nAPIs. In particular, it specifies the following:   Error responses MUST use standard HTTP status codes in the 400 or 500 range to\n  detail the general category of error.  Error responses will be of the  Content-Type   application/problem ,\n  appending a serialization format of either  json  or  xml :\n   application/problem+json ,  application/problem+xml .  Error responses will have each of the following keys:  detail , a human-readable description of the specific error.  type , a unique URI for the general error type, generally pointing to\n    human-readable documentation of that given type.  title , a short, human-readable title for the general error type; the title\n    should not change for given  type s.  status , conveying the HTTP status code; this is so that all information\n    is in one place, but also to correct for changes in the status code due to\n    usage of proxy servers.   Optionally, an  instance  key may be present, with a unique URI for the specific\nerror; this will often point to an error log for that specific response.  Finally, problem details are  extensible . You may provide additional keys that\ngive the consumer more information about the error. As an example, in an API\nthat has rate limiting, you may want to indicate how many requests the user has\nmade, what the rate limit is, and when the limit resets:  {\n    \"type\": \"https://example.com/problems/rate-limit-exceeded\",\n    \"title\": \"You have exceeded your API rate limit.\",\n    \"detail\": \"You have hit your rate limit of 5000 requests per hour.\",\n    \"requests_this_hour\": 5025,\n    \"rate_limit\": 5000,\n    \"rate_limit_reset\": \"2017-05-03T14:39-0500\"\n}",
            "title": "Problem Details for HTTP APIs"
        },
        {
            "location": "/intro/#custom-errors",
            "text": "What if you have custom error types?  RFC 7807 specifically allows you to define these with the following:   A URI to documentation of the error  type .  A human-readable  title  describing the error type.  One or more HTTP  status  codes associated with the error type.   For your custom errors, you use the above with a problem details response; if\nthe problem type requires additional information, you provide it within the\npayload, and document that information at the URI describing the type.  This approach allows usage of a single, general-purpose media type for returning\nproblem details for your HTTP API, while allowing full customization of what\ntypes of errors you report.",
            "title": "Custom errors"
        },
        {
            "location": "/intro/#problemdetails",
            "text": "This library provides custom PSR-7 responses for JSON and XML representations of application/problem . Additionally, it provides a factory that will introspect\nthe contents of a provided  Accept  header in order to determine which\nrepresentation to return, defaulting to the XML representation. This factory may\nthen be composed in middleware in order to create and return problem details\nresponses.  Additionally, the library provides middleware that acts as an error and\nexception handler and wrapping calls to a delegate, converting each into problem\ndetails responses.",
            "title": "ProblemDetails"
        },
        {
            "location": "/response/",
            "text": "Problem Details Responses\n\n\nWhen writing middleware, you will often be able to detect error conditions\nwithin the middleware logic. When you do, you can immediately return a problem\ndetails response.\n\n\nThis library provides the following:\n\n\n\n\nProblemDetailsResponse\n is an interface defining two static methods, \ncreate\n\n  and \ncreateFromThrowable()\n.\n\n\nProblemDetailsJsonResponse\n implements \nProblemDetailsResponse\n and extends\n  \nZend\\Diactoros\\Response\\JsonResponse\n in order to provide a JSON\n  representation of problem details.\n\n\nProblemDetailsXmlResponse\n implements \nProblemDetailsResponse\n and extends\n  \nZend\\Diactoros\\Response\\TextResponse\n in order to provide an XML\n  representation of problem details.\n\n\nProblemDetailsResponseFactory\n defines two static methods, \ncreateResponse()\n\n  and \ncreateResponseFromThrowable()\n. Each accepts the same arguments as the\n  \ncreate()\n and \ncreateFromThrowable()\n methods of \nProblemDetailsResponse\n,\n  respectively, but with an additional initial argument, \n$accept\n, representing\n  an \nAccept\n header to negotiate in order to determine which specific response\n  type to create.\n\n\n\n\nThe signature of \nProblemDetailsResponse\n is as follows:\n\n\nnamespace ProblemDetails;\n\nuse Throwable;\n\ninterface ProblemDetailsResponse\n{\n    const INCLUDE_THROWABLE_DETAILS = true;\n    const EXCLUDE_THROWABLE_DETAILS = false;\n\n    public static function create(\n        int $status,\n        string $detail,\n        string $title = '',\n        string $type = '',\n        array $additional = []\n    ) : ProblemDetailsResponse;\n\n    public static function createFromThrowable(\n        Throwable $e,\n        bool $includeThrowable = self::EXCLUDE_THROWABLE_DETAILS\n    ) : ProblemDetailsResponse;\n}\n\n\n\n\nWhile that for \nProblemDetailsResponseFactory\n is this:\n\n\nnamespace ProblemDetails;\n\nuse Negotiation\\Negotiator;\nuse Throwable;\n\nclass ProblemDetailsResponseFactory\n{\n    public static function createResponse(\n        string $accept,\n        int $status,\n        string $detail,\n        string $title = '',\n        string $type = '',\n        array $additional = []\n    ) : ProblemDetailsResponse;\n\n    public static function createResponseFromThrowable(\n        string $accept,\n        Throwable $e,\n        bool $includeThrowable = ProblemDetailsResponse::EXCLUDE_THROWABLE_DETAILS\n    ) : ProblemDetailsResponse;\n}\n\n\n\n\nExamples\n\n\nReturning a JSON or XML response\n\n\nLet's say you have middleware that you know will only be used in a JSON context,\nand need to return problem details:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsJsonResponse;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // discovered an error, so returning problem details:\n        return ProblemDetailsJsonResponse::create(\n            403,\n            'You do not have valid credentials to access ' . $request->getUri()->getPath(),\n            '',\n            '',\n            ['login' => '/login']\n        );\n    }\n}\n\n\n\n\nIf you wanted to return an XML version instead, you would replace\n\nProblemDetailsJsonResponse\n with \nProblemDetailsXmlResponse\n in the above\nexample.\n\n\nUsing a Throwable to create the response\n\n\nLet's say you have middleware that invokes functionality from a service it\ncomposes, and that service could raise an exception or other \nThrowable\n. For\nthis, you can use the \ncreateFromThrowable()\n method instead.\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsJsonResponse;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return ProblemDetailsJsonResponse::createFromThrowable($e);\n        }\n    }\n}\n\n\n\n\nAs with the previous example, for an XML serialization, you would substitute\n\nProblemDetailsXmlResponse\n for \nProblemDetailsJsonResponse\n.\n\n\nBy default, \ncreateFromThrowable()\n will only use the exception message, and\npotentially the exception code (if it falls in the 400 or 500 range). If you\nwant to include full exception details \u2014 line, file, backtrace, previous\nexceptions \u2014 you must pass a boolean \ntrue\n as the second argument to the\nmethod. In most cases, you should only do this in your development or testing\nenvironment; as such, you would need to provide a flag to your middleware to use\nwhen invoking the \ncreateFromThrowable()\n method. As a more complete example:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsJsonResponse;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    private $debug;\n\n    public function __construct(/* other arguments*/ boolean $debug = false)\n    {\n        // ...\n        $this->debug = $debug;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return ProblemDetailsJsonResponse::createFromThrowable($e, $this->debug);\n        }\n    }\n}\n\n\n\n\nVarying the serialization based on Accept header\n\n\nIf your API should respond to either JSON or XML requests, you will need to use\nthe \nProblemDetailsResponseFactory\n to create the response. To do so, you will\npull the \nAccept\n header from the request when passing it to the factory.\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsResponseFactory;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // discovered an error, so returning problem details:\n        return ProblemDetailsResponseFactory::create(\n            $request->getHeaderLine('Accept'),\n            403,\n            'You do not have valid credentials to access ' . $request->getUri()->getPath(),\n            '',\n            '',\n            ['login' => '/login']\n        );\n    }\n}\n\n\n\n\nIf you wish to use a \nThrowable\n or \nException\n to create the response, you\nwould use \ncreateResponseFromThrowable()\n; just like \ncreateFromThrowable()\n\nthis method also accepts the flag for whether or not to include\nexception/throwable details.\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsResponseFactory;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    private $debug;\n\n    public function __construct(/* other arguments*/ boolean $debug = false)\n    {\n        // ...\n        $this->debug = $debug;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return ProblemDetailsResponseFactory::createResponseFromThrowable(\n                $request->getHeaderLine('Accept'),\n                $e,\n                $this->debug\n            );\n        }\n    }\n}\n\n\n\n\nCreating Custom Response Types\n\n\nIf you have common problem types you will use over and over again, you may not\nwish to provide the \ntype\n, \ntitle\n, and/or \nstatus\n each time you create the\nproblem details. For those, we suggest creating extensions to\n\nProblemDetailsResponseFactory\n. To use the example from the introduction, we\ncould have a \nRateLimitResponse\n generated as follows:\n\n\nuse ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass RateLimitResponseFactory extends ProblemDetailsResponseFactory\n{\n    const STATUS = 403;\n    const TITLE = 'https://example.com/problems/rate-limit-exceeded';\n    const TYPE = 'You have exceeded the rate limit.';\n\n    public static function create(\n        string $accept,\n        int $tries,\n        int $rateLimit,\n        int $expires\n    ) {\n        return self::createResponse(\n            $accept,\n            self::STATUS,\n            sprintf('You have exceeded your %d requests per hour rate limit', $rateLimit),\n            self::TITLE,\n            self::TYPE,\n            [\n                'requests_this_hour' => $tries,\n                'rate_limit' => $rateLimit,\n                'rate_limit_reset' => date('c', $expires),\n            ]\n        );\n    }\n}\n\n\n\n\nYou would then create and return your response as follows:\n\n\nRateLimitResponseFactory::create(\n    $request->getHeaderLine('Accept'),\n    $tries,\n    $rateLimit,\n    $expires\n);",
            "title": "Response Types"
        },
        {
            "location": "/response/#problem-details-responses",
            "text": "When writing middleware, you will often be able to detect error conditions\nwithin the middleware logic. When you do, you can immediately return a problem\ndetails response.  This library provides the following:   ProblemDetailsResponse  is an interface defining two static methods,  create \n  and  createFromThrowable() .  ProblemDetailsJsonResponse  implements  ProblemDetailsResponse  and extends\n   Zend\\Diactoros\\Response\\JsonResponse  in order to provide a JSON\n  representation of problem details.  ProblemDetailsXmlResponse  implements  ProblemDetailsResponse  and extends\n   Zend\\Diactoros\\Response\\TextResponse  in order to provide an XML\n  representation of problem details.  ProblemDetailsResponseFactory  defines two static methods,  createResponse() \n  and  createResponseFromThrowable() . Each accepts the same arguments as the\n   create()  and  createFromThrowable()  methods of  ProblemDetailsResponse ,\n  respectively, but with an additional initial argument,  $accept , representing\n  an  Accept  header to negotiate in order to determine which specific response\n  type to create.   The signature of  ProblemDetailsResponse  is as follows:  namespace ProblemDetails;\n\nuse Throwable;\n\ninterface ProblemDetailsResponse\n{\n    const INCLUDE_THROWABLE_DETAILS = true;\n    const EXCLUDE_THROWABLE_DETAILS = false;\n\n    public static function create(\n        int $status,\n        string $detail,\n        string $title = '',\n        string $type = '',\n        array $additional = []\n    ) : ProblemDetailsResponse;\n\n    public static function createFromThrowable(\n        Throwable $e,\n        bool $includeThrowable = self::EXCLUDE_THROWABLE_DETAILS\n    ) : ProblemDetailsResponse;\n}  While that for  ProblemDetailsResponseFactory  is this:  namespace ProblemDetails;\n\nuse Negotiation\\Negotiator;\nuse Throwable;\n\nclass ProblemDetailsResponseFactory\n{\n    public static function createResponse(\n        string $accept,\n        int $status,\n        string $detail,\n        string $title = '',\n        string $type = '',\n        array $additional = []\n    ) : ProblemDetailsResponse;\n\n    public static function createResponseFromThrowable(\n        string $accept,\n        Throwable $e,\n        bool $includeThrowable = ProblemDetailsResponse::EXCLUDE_THROWABLE_DETAILS\n    ) : ProblemDetailsResponse;\n}",
            "title": "Problem Details Responses"
        },
        {
            "location": "/response/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/response/#returning-a-json-or-xml-response",
            "text": "Let's say you have middleware that you know will only be used in a JSON context,\nand need to return problem details:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsJsonResponse;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // discovered an error, so returning problem details:\n        return ProblemDetailsJsonResponse::create(\n            403,\n            'You do not have valid credentials to access ' . $request->getUri()->getPath(),\n            '',\n            '',\n            ['login' => '/login']\n        );\n    }\n}  If you wanted to return an XML version instead, you would replace ProblemDetailsJsonResponse  with  ProblemDetailsXmlResponse  in the above\nexample.",
            "title": "Returning a JSON or XML response"
        },
        {
            "location": "/response/#using-a-throwable-to-create-the-response",
            "text": "Let's say you have middleware that invokes functionality from a service it\ncomposes, and that service could raise an exception or other  Throwable . For\nthis, you can use the  createFromThrowable()  method instead.  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsJsonResponse;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return ProblemDetailsJsonResponse::createFromThrowable($e);\n        }\n    }\n}  As with the previous example, for an XML serialization, you would substitute ProblemDetailsXmlResponse  for  ProblemDetailsJsonResponse .  By default,  createFromThrowable()  will only use the exception message, and\npotentially the exception code (if it falls in the 400 or 500 range). If you\nwant to include full exception details \u2014 line, file, backtrace, previous\nexceptions \u2014 you must pass a boolean  true  as the second argument to the\nmethod. In most cases, you should only do this in your development or testing\nenvironment; as such, you would need to provide a flag to your middleware to use\nwhen invoking the  createFromThrowable()  method. As a more complete example:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsJsonResponse;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    private $debug;\n\n    public function __construct(/* other arguments*/ boolean $debug = false)\n    {\n        // ...\n        $this->debug = $debug;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return ProblemDetailsJsonResponse::createFromThrowable($e, $this->debug);\n        }\n    }\n}",
            "title": "Using a Throwable to create the response"
        },
        {
            "location": "/response/#varying-the-serialization-based-on-accept-header",
            "text": "If your API should respond to either JSON or XML requests, you will need to use\nthe  ProblemDetailsResponseFactory  to create the response. To do so, you will\npull the  Accept  header from the request when passing it to the factory.  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsResponseFactory;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // discovered an error, so returning problem details:\n        return ProblemDetailsResponseFactory::create(\n            $request->getHeaderLine('Accept'),\n            403,\n            'You do not have valid credentials to access ' . $request->getUri()->getPath(),\n            '',\n            '',\n            ['login' => '/login']\n        );\n    }\n}  If you wish to use a  Throwable  or  Exception  to create the response, you\nwould use  createResponseFromThrowable() ; just like  createFromThrowable() \nthis method also accepts the flag for whether or not to include\nexception/throwable details.  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse ProblemDetails\\ProblemDetailsResponseFactory;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    private $debug;\n\n    public function __construct(/* other arguments*/ boolean $debug = false)\n    {\n        // ...\n        $this->debug = $debug;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return ProblemDetailsResponseFactory::createResponseFromThrowable(\n                $request->getHeaderLine('Accept'),\n                $e,\n                $this->debug\n            );\n        }\n    }\n}",
            "title": "Varying the serialization based on Accept header"
        },
        {
            "location": "/response/#creating-custom-response-types",
            "text": "If you have common problem types you will use over and over again, you may not\nwish to provide the  type ,  title , and/or  status  each time you create the\nproblem details. For those, we suggest creating extensions to ProblemDetailsResponseFactory . To use the example from the introduction, we\ncould have a  RateLimitResponse  generated as follows:  use ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass RateLimitResponseFactory extends ProblemDetailsResponseFactory\n{\n    const STATUS = 403;\n    const TITLE = 'https://example.com/problems/rate-limit-exceeded';\n    const TYPE = 'You have exceeded the rate limit.';\n\n    public static function create(\n        string $accept,\n        int $tries,\n        int $rateLimit,\n        int $expires\n    ) {\n        return self::createResponse(\n            $accept,\n            self::STATUS,\n            sprintf('You have exceeded your %d requests per hour rate limit', $rateLimit),\n            self::TITLE,\n            self::TYPE,\n            [\n                'requests_this_hour' => $tries,\n                'rate_limit' => $rateLimit,\n                'rate_limit_reset' => date('c', $expires),\n            ]\n        );\n    }\n}  You would then create and return your response as follows:  RateLimitResponseFactory::create(\n    $request->getHeaderLine('Accept'),\n    $tries,\n    $rateLimit,\n    $expires\n);",
            "title": "Creating Custom Response Types"
        },
        {
            "location": "/middleware/",
            "text": "Problem Details Middleware\n\n\nWhile returning a problem details response from your own middleware is powerful\nand flexible, sometimes you may want a fail-safe way to return problem details\nfor any exception or PHP error that occurs without needing to catch and handle\nthem yourself.\n\n\nFor this purpose, this library provides \nProblemDetailsMiddleware\n.\n\n\nThis middleware does the following:\n\n\n\n\nComposes an \n$includeThrowableDetail\n flag, \nfalse\n by default, to indicate if\n  throwable/exception details should be provided with responses.\n\n\nRegisters a PHP error handler using the current \nerror_reporting\n mask, and\n  throwing any errors handled as \nErrorException\n instances.\n\n\nWraps a call to the \n$delegate\n in a \ntry\n/\ncatch\n block; if nothing is\n  caught, and a response is returned, it returns the response immediately. If a\n  response is \nnot\n returned, it raises a \nProblemDetails\\MissingResponseException\n.\n\n\nFor all caught throwables, it pulls the \nAccept\n header and determines if the\n  client can accept either JSON or XML. If it can accept neither, the exception is\n  re-thrown.\n\n\nFor acceptable responses, it passes the accept header, caught throwable, and\n  \n$includeThrowableDetail\n flag to the\n  \nProblemDetailsResponseFactory::createResponseFromThrowable()\n method, and\n  returns the generated response.\n\n\n\n\nAs such, you can register this in middleware stacks in order to automate\ngeneration of problem details for exceptions and PHP errors.\n\n\nAs an example, using Expressive, you could compose it as an error handler within\nyour application pipeline, having it handle \nall\n errors and exceptions from\nyour application:\n\n\n$app->pipe(ProblemDetailsMiddleware::class);\n\n\n\n\nOr for a subpath of your application:\n\n\n$app->pipe('/api', 'ProblemDetailsMiddleware::class);\n\n\n\n\nAlternately, you could pipe it within a routed-middleware pipeline:\n\n\n$app->get('/api/books', [\n    ProblemDetailsMiddleware::class,\n    BooksList::class,\n], 'books');\n\n\n\n\nThis latter approach ensures that you are only providing problem details for\nspecific API endpoints, which can be useful when you have a mix of APIs and\ntraditional web content in your application.\n\n\nFactory\n\n\nThe \nProblemDetailsMiddleware\n ships with a corresponding PSR-11 compatible factory,\n\nProblemDetailsMiddlewareFactory\n. This factory looks for a service named\n\nconfig\n containing a \ndebug\n key; the value of that key is then used to create\nthe \nProblemDetailsMiddleware\n instance itself.\n\n\nFor Expressive 2 users, this middleware should be registered automatically with\nyour application on install, assuming you have the zend-component-installer\nplugin in place (it's shipped by default with the Expresive skeleton).",
            "title": "Error Handling Middleware"
        },
        {
            "location": "/middleware/#problem-details-middleware",
            "text": "While returning a problem details response from your own middleware is powerful\nand flexible, sometimes you may want a fail-safe way to return problem details\nfor any exception or PHP error that occurs without needing to catch and handle\nthem yourself.  For this purpose, this library provides  ProblemDetailsMiddleware .  This middleware does the following:   Composes an  $includeThrowableDetail  flag,  false  by default, to indicate if\n  throwable/exception details should be provided with responses.  Registers a PHP error handler using the current  error_reporting  mask, and\n  throwing any errors handled as  ErrorException  instances.  Wraps a call to the  $delegate  in a  try / catch  block; if nothing is\n  caught, and a response is returned, it returns the response immediately. If a\n  response is  not  returned, it raises a  ProblemDetails\\MissingResponseException .  For all caught throwables, it pulls the  Accept  header and determines if the\n  client can accept either JSON or XML. If it can accept neither, the exception is\n  re-thrown.  For acceptable responses, it passes the accept header, caught throwable, and\n   $includeThrowableDetail  flag to the\n   ProblemDetailsResponseFactory::createResponseFromThrowable()  method, and\n  returns the generated response.   As such, you can register this in middleware stacks in order to automate\ngeneration of problem details for exceptions and PHP errors.  As an example, using Expressive, you could compose it as an error handler within\nyour application pipeline, having it handle  all  errors and exceptions from\nyour application:  $app->pipe(ProblemDetailsMiddleware::class);  Or for a subpath of your application:  $app->pipe('/api', 'ProblemDetailsMiddleware::class);  Alternately, you could pipe it within a routed-middleware pipeline:  $app->get('/api/books', [\n    ProblemDetailsMiddleware::class,\n    BooksList::class,\n], 'books');  This latter approach ensures that you are only providing problem details for\nspecific API endpoints, which can be useful when you have a mix of APIs and\ntraditional web content in your application.",
            "title": "Problem Details Middleware"
        },
        {
            "location": "/middleware/#factory",
            "text": "The  ProblemDetailsMiddleware  ships with a corresponding PSR-11 compatible factory, ProblemDetailsMiddlewareFactory . This factory looks for a service named config  containing a  debug  key; the value of that key is then used to create\nthe  ProblemDetailsMiddleware  instance itself.  For Expressive 2 users, this middleware should be registered automatically with\nyour application on install, assuming you have the zend-component-installer\nplugin in place (it's shipped by default with the Expresive skeleton).",
            "title": "Factory"
        },
        {
            "location": "/exception/",
            "text": "Problem Details Exceptions\n\n\nIf you are developing an API, it may be useful to raise exceptions from your\nbusiness domain that contain all the information necessary to report problem\ndetails.\n\n\nTo facilitate this, we provide an interface, \nProblemDetailsException\n:\n\n\nnamespace ProblemDetails;\n\nuse JsonSerializable;\n\ninterface ProblemDetailsException extends JsonSerializable\n{\n    public function getStatus() : int;\n\n    public function getType() : string;\n\n    public function getTitle() : string;\n\n    public function getDetail() : string;\n\n    public function getAdditionalData() : array;\n\n    public function toArray() : array;\n}\n\n\n\n\nYou may create exceptions that implement this interface. When such exceptions\nare passed to \nProblemDetailsResponse::createFromThrowable()\n or\n\nProblemDetailsResponseFactory::createResponseFromThrowable()\n, these will pull\nthe relevant details in order to create a \nProblemDetailsResponse\n.\n\n\nTo facilitate creating such exception types, we also ship the trait\n\nCommonProblemDetailsException\n. This trait defines the following properties:\n\n\n\n\n$status\n\n\n$detail\n\n\n$title\n\n\n$type\n\n\n$additional\n\n\n\n\nand implements each of the methods of the interface. This allows you as a\ndeveloper to create implementations with either constructors or named\nconstructors for generating exception instances.\n\n\nAs an example, if you wanted to create an exception type for providing\ntransaction problem details, you might do so as follows:\n\n\nuse DomainException;\nuse ProblemDetails\\CommonProblemDetailsException;\nuse ProblemDetails\\ProblemDetailsException;\n\nclass TransactionException extends DomainException implements ProblemDetailsException\n{\n    use CommonProblemDetailsException;\n\n    const STATUS = 403;\n    const TYPE = 'https://example.com/problems/insufficient-funds';\n    const TITLE = 'You have insufficient funds to complete the transaction.';\n\n    public static function create(int $needed, float $balance, string $account) : self\n    {\n        $e = new self(sprintf(\n            'Your transaction required %01.2f, but you only have %01.2f in your account',\n            $needed,\n            $balance\n        ));\n        $e->status = self::STATUS;\n        $e->type   = self::TYPE;\n        $e->title  = self::TITLE;\n        $e->additional = [\n            'account' => $account,\n            'balance' => $balance,\n        ];\n\n        return $e;\n    }\n}\n\n\n\n\nYou might then raise the exception as follows:\n\n\nthrow TransactionException::create($price, $balance, $accountUri);\n\n\n\n\nAnd it might result in the following:\n\n\n{\n    \"status\": 403,\n    \"type\": \"https://example.com/problems/insufficient-funds\",\n    \"title\": \"You have insufficient funds to complete the transaction.\",\n    \"detail\": \"Your transaction required 5.63, but you only have 1.37 in your account\",\n    \"account\": \"https://example.com/api/accounts/12345\",\n    \"balance\": 1.37,\n}\n\n\n\n\nThe benefit to this approach is that you can easily provide domain-specific\nexceptions throughout your application that can, as a side-effect, be\nre-purposed immediately to provide problem details in your application.",
            "title": "Exceptions"
        },
        {
            "location": "/exception/#problem-details-exceptions",
            "text": "If you are developing an API, it may be useful to raise exceptions from your\nbusiness domain that contain all the information necessary to report problem\ndetails.  To facilitate this, we provide an interface,  ProblemDetailsException :  namespace ProblemDetails;\n\nuse JsonSerializable;\n\ninterface ProblemDetailsException extends JsonSerializable\n{\n    public function getStatus() : int;\n\n    public function getType() : string;\n\n    public function getTitle() : string;\n\n    public function getDetail() : string;\n\n    public function getAdditionalData() : array;\n\n    public function toArray() : array;\n}  You may create exceptions that implement this interface. When such exceptions\nare passed to  ProblemDetailsResponse::createFromThrowable()  or ProblemDetailsResponseFactory::createResponseFromThrowable() , these will pull\nthe relevant details in order to create a  ProblemDetailsResponse .  To facilitate creating such exception types, we also ship the trait CommonProblemDetailsException . This trait defines the following properties:   $status  $detail  $title  $type  $additional   and implements each of the methods of the interface. This allows you as a\ndeveloper to create implementations with either constructors or named\nconstructors for generating exception instances.  As an example, if you wanted to create an exception type for providing\ntransaction problem details, you might do so as follows:  use DomainException;\nuse ProblemDetails\\CommonProblemDetailsException;\nuse ProblemDetails\\ProblemDetailsException;\n\nclass TransactionException extends DomainException implements ProblemDetailsException\n{\n    use CommonProblemDetailsException;\n\n    const STATUS = 403;\n    const TYPE = 'https://example.com/problems/insufficient-funds';\n    const TITLE = 'You have insufficient funds to complete the transaction.';\n\n    public static function create(int $needed, float $balance, string $account) : self\n    {\n        $e = new self(sprintf(\n            'Your transaction required %01.2f, but you only have %01.2f in your account',\n            $needed,\n            $balance\n        ));\n        $e->status = self::STATUS;\n        $e->type   = self::TYPE;\n        $e->title  = self::TITLE;\n        $e->additional = [\n            'account' => $account,\n            'balance' => $balance,\n        ];\n\n        return $e;\n    }\n}  You might then raise the exception as follows:  throw TransactionException::create($price, $balance, $accountUri);  And it might result in the following:  {\n    \"status\": 403,\n    \"type\": \"https://example.com/problems/insufficient-funds\",\n    \"title\": \"You have insufficient funds to complete the transaction.\",\n    \"detail\": \"Your transaction required 5.63, but you only have 1.37 in your account\",\n    \"account\": \"https://example.com/api/accounts/12345\",\n    \"balance\": 1.37,\n}  The benefit to this approach is that you can easily provide domain-specific\nexceptions throughout your application that can, as a side-effect, be\nre-purposed immediately to provide problem details in your application.",
            "title": "Problem Details Exceptions"
        }
    ]
}